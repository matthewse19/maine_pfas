[{"name": "app.py", "content": "from shiny import App, ui, render, reactive\nimport geopandas as gpd\nimport pandas as pd\nfrom pyodide.http import open_url\nimport folium\nfrom io import StringIO\nfrom ratelimit import debounce, throttle\n\nna_color = \"#ccccccff\"\nlegend_colors = [\"#5bb6a9ff\", \"#ceeb9cff\", \"#fdcc7aff\", \"#ed6345ff\", \"#9e0142ff\"]\nlegend_splits = [0, 50, 100, 500, 1000]\nlegend_labels = [\n    f\"[{legend_splits[i]} - {legend_splits[i+1]}%)\"\n    for i in range(len(legend_splits) - 1)\n]\nlegend_labels.append(f\"[{legend_splits[-1]}% +\")\n\n\ndef color_lookup(x):\n    if pd.isna(x):\n        return na_color\n    for color, upper_bound in zip(legend_colors[:-1], legend_splits[1:]):\n        if x < upper_bound:\n            return color\n\n    return legend_colors[-1]\n\n\n# Define thresholds\nthresholds = {\n    \"Drinking Water\": {\n        \"PFOA\": 4,\n        \"PFOS\": 4,\n        \"PFHXS\": 10,\n        \"HFPO-DA\": 10,\n        \"PFNA\": 10,\n        \"SUM OF 6 PFAS\": 20,\n    },\n    \"Soil\": {\n        \"PFOA\": 740,\n        \"PFOS\": 490,\n        \"PFHXS\": 4900,\n        \"PFNA\": 740,\n        \"PFBS\": 74000,\n        \"PFBA\": 300000,\n        \"PFHXA\": 120000,\n    },\n    \"Milk\": {\"PFOS\": 210},\n    \"Meat\": {\"PFOS\": 3.4},\n    \"Filet\": {\"PFOS\": 3.5},\n}\n\nunits = {\n    \"Drinking Water\": \"ng/L\",\n    \"Soil\": \"ng/g\",\n    \"Milk\": \"ng/L\",\n    \"Meat\": \"ng/g\",\n    \"Filet\": \"ng/g\",\n}\n\nsample_types = list(thresholds.keys())\n\ndefaultChem = \"PFOA\"\n\ncleaned_data_file = open_url(\n    \"https://raw.githubusercontent.com/matthewse19/maine_pfas/main/data/cleaned_data.csv\"\n)\n\ndf = pd.read_csv(cleaned_data_file)\ndf[\"sample_date\"] = pd.to_datetime(df[\"sample_date\"])\nmin_date = min(df[\"sample_date\"])\nmax_date = max(df[\"sample_date\"])\ndf[\"threshold_pct\"] = df[\"threshold_pct\"].astype(float)\n\n\n# round values > 1 to 2 decimal places, keep 3 significant decimal places for values < 1\ndef custom_round(number):\n    if pd.isna(number):\n        return number\n    if number > 1:\n        return round(number, 2)\n    elif 0 < number < 1:\n        return round(number, -int(format(number, \".1e\").split(\"e\")[1]) + 2)\n    else:\n        return number  # for handling 1, 0, or negative numbers if necessary\n\n\ndf[\"threshold_pct\"] = df[\"threshold_pct\"].apply(custom_round)\n\n\n# Load the GeoJSON data\ngeo_json_file = open_url(\n    \"https://raw.githubusercontent.com/matthewse19/maine_pfas/main/data/geojson_maine_towns.json\"\n)\ngeojson_data = gpd.read_file(geo_json_file)\ngeojson_data = geojson_data.drop([\"created_date\", \"last_edited_date\"], axis=1)\ngeojson_data = geojson_data.rename({\"TOWN\": \"town\"}, axis=1)\n\n\n# Filter dataframe to get the maximum concentration for each town\ndisp_data = (\n    df[df[\"parameter\"] == defaultChem]\n    .groupby(\"town\")[\"concentration\"]\n    .max()\n    .reset_index()\n)\n\n# Merge GeoJSON data with the filtered concentration data\ngeo_disp_data = geojson_data.merge(disp_data, how=\"inner\", on=\"town\")\n\nget_checkbox_name = lambda x: f\"{x.replace(' ', '_')}_checkbox\"\n\nsample_threshold_checkboxes = [\n    ui.input_checkbox_group(\n        get_checkbox_name(sample_type),\n        label=f\"{sample_type}\",\n        choices={\n            parameter: f\"{parameter} - {threshold:,} {units[sample_type]}\"\n            for parameter, threshold in thresholds[sample_type].items()\n        },\n        selected=(\n            list(thresholds[sample_type].keys())\n            if sample_type == \"Drinking Water\"\n            else []\n        ),\n    )\n    for sample_type in sample_types\n]\n\n# Define UI for application\napp_ui = ui.page_fluid(\n    ui.panel_title(\"PFAS Readings in Maine Towns\"),\n    ui.panel_well(\n        ui.p(\n            \"\"\"This page displays the most recent readings of PFAS chemicals gathered by the Maine Department of Environmental Protection (DEP), and displays these measurements\n        as a percentage of their Maximum Containment Level (MCL) or their Remedial Action Guideline (RAG) Screen Levels, as defined by the \n        EPA and Maine DEP respectively.\n        \"\"\"\n        ),\n        ui.p(\n            ui.strong(\"Reading the map: \"),\n            \"The color of each town corresponds with the reading which was the  \",\n            ui.em(\"highest percentage\"),\n            \" of the chemical and sample type's threshold (either MCL or RAG).\",\n        ),\n        ui.p(\n            \"\"\"The data can be aggregated and filtered by type of chemical, sample type, or date of measurement with the panel on the left.\n            \"\"\"\n        ),\n        ui.p(\n            \"\"\"See below for further information on sources, methodology, and more links.\n            \"\"\"\n        ),\n    ),\n    ui.layout_sidebar(\n        ui.sidebar(\n            (\n                ui.output_ui(\"legend\"),\n                *sample_threshold_checkboxes,\n                ui.input_date_range(\n                    \"date_range\",\n                    label=\"Test date range\",\n                    start=min_date,\n                    end=max_date,\n                    min=min_date,\n                    max=max_date + pd.DateOffset(1),\n                    startview=\"year\",\n                ),\n            ),\n            width=\"20%\",\n        ),\n        ui.output_ui(\"map\", fill=True, fillable=True),\n    ),\n    ui.card(\n        ui.card_header(\"Further info & sources\"),\n        ui.strong(\"Thresholds - MCLs and RAGs\"),\n        ui.p(\n            \"The MCLs for drinking water created by the EPA for PFOA, PFOS, PFHxS, PFNA, and HFPO-DA can be found at \",\n            ui.a(\n                \"[1]\",\n                href=r\"https://www.epa.gov/sdwa/and-polyfluoroalkyl-substances-pfas\",\n            ),\n            '. Additionally, Maine DEP has an residential drinking water standard for \"SUM OF 6 PFAS\", which is the sum of PFOS + PFOA + PFHpA + PFNA + PFHxS + PFDA ',\n            ui.a(\n                \"[2]\",\n                href=r\"https://www.maine.gov/dep/spills/topics/pfas/Maine%20PFAS%20Screening%20Levels_Rev_12_4_23.pdf\",\n            ),\n            \".\",\n        ),\n        ui.p(\n            \"\"\"The Maine DEP also has RAGs for milk, meat, and fissue tissue (filet). There are also different guidelines for soil depending on\n            where the soil is found. For simplicity, the above soil thresholds are from the \"Park User\" category,\n             regardless of where the soil sample was taken (and the units are in ng/g)\n            \"\"\",\n            ui.a(\n                \"[2]\",\n                href=r\"https://www.maine.gov/dep/spills/topics/pfas/Maine%20PFAS%20Screening%20Levels_Rev_12_4_23.pdf\",\n            ),\n            \".\",\n        ),\n        ui.strong(\"Data\"),\n        ui.p(\n            \"The raw data can be accessed at \",\n            ui.a(\"[3]\", href=\"https://www.maine.gov/dep/spills/topics/pfas/#Data\"),\n            \" and the processed data can be found in the below GitHub repository.\",\n        ),\n        ui.strong(\"Sources\"),\n        ui.p(\n            r\"[1] Environmental Protection Agency. (n.d.). Per- and Polyfluoroalkyl Substances (PFAS). EPA.\\n\\thttps://www.epa.gov/sdwa/and-polyfluoroalkyl-substances-pfas\"\n        ),\n        ui.p(\n            r\"[2] MAINE PFAS SCREENING LEVELS . maine.gove. (2023, December). https://www.maine.gov/dep/spills/topics/pfas/Maine%20PFAS%20Screening%20Levels_Rev_12_4_23.pdf\"\n        ),\n        ui.p(\n            r\"[3] Per- and polyfluoroalkyl substances (PFAS). Maine Department of Environmental Protection. (n.d.). https://www.maine.gov/dep/spills/topics/pfas/#Data\"\n        ),\n        ui.card_footer(\"See \", ui.a(\"https://github.com/matthewse19/maine_pfas\")),\n    ),\n)\n\n\n# Define server logic\ndef server(input, output, session):\n    @debounce(0.75)\n    @reactive.Calc\n    def debounced_sample_check_values():\n        sample_check_values = {\n            sample_type: input[get_checkbox_name(sample_type)]()\n            for sample_type in sample_types\n        }\n\n        return sample_check_values\n\n    @reactive.Calc\n    def data_filtered():\n        # Get the selected date range\n        start_date = input.date_range()[0]\n        end_date = input.date_range()[1]\n\n        disp_data_filtered = df[\n            (df[\"sample_date\"] >= pd.to_datetime(start_date))\n            & (df[\"sample_date\"] <= pd.to_datetime(end_date))\n        ]\n\n        # filter data according to checkboxes\n        def chems_sample_filter(chems, sample):\n            return (\n                lambda row: row[\"parameter\"] in chems and row[\"sample_type\"] == sample\n            )\n\n        sample_check_values = debounced_sample_check_values()\n        all_filters = [\n            chems_sample_filter(sample_check_values[sample_type], sample_type)\n            for sample_type in thresholds.keys()\n        ]\n        row_all_filters = lambda row: any(f(row) for f in all_filters)\n        disp_data_filtered = disp_data_filtered[\n            disp_data_filtered.apply(row_all_filters, axis=1)\n        ]\n\n        # get idxs of max values in each grouped town\n        max_ids = (\n            disp_data_filtered.groupby(\"town\")[\"threshold_pct\"].transform(\"max\")\n            == disp_data_filtered[\"threshold_pct\"]\n        )\n        # get entire DF, and only keep one row per town (arbitrarily keep first)\n        disp_data_filtered = disp_data_filtered[max_ids].drop_duplicates([\"town\"])\n        disp_data_filtered[\"sample_date\"] = disp_data_filtered[\"sample_date\"].astype(\n            str\n        )\n\n        if len(disp_data_filtered) == 0:\n            return None\n\n        return geojson_data.merge(disp_data_filtered, how=\"inner\", on=\"town\")\n\n    @output\n    @render.ui\n    def legend():\n        # Create HTML for the legend\n        legend_html = (\n            '<div style=\"padding: 10px; border: 2px solid black; width: 150px;\">'\n        )\n        legend_html += \"<b>% of chemical threshold</b><br>\"\n        for color, label in zip(legend_colors, legend_labels):\n            legend_html += f'<div style=\"display: flex; align-items: center;\"><div style=\"width: 20px; height: 20px; background-color: {color}; margin-right: 5px;\"></div>{label}</div>'\n        legend_html += \"</div>\"\n\n        return ui.HTML(legend_html)\n\n    @output\n    @render.ui\n    def map():\n        geojson = data_filtered()\n        if geojson is None:\n            return None\n\n        m = folium.Map(\n            location=[45.2538, -69.4455],\n            zoom_start=7,\n            tiles=\"CartoDB Positron\",\n        )\n        geo = folium.GeoJson(\n            data=geojson,\n            style_function=lambda feature: {\n                \"fillColor\": color_lookup(feature[\"properties\"][\"threshold_pct\"]),\n                \"color\": \"black\",\n                \"weight\": 0.5,\n                \"fillOpacity\": 0.7,\n            },\n        ).add_to(m)\n\n        folium.GeoJsonTooltip(\n            [\n                \"town\",\n                \"threshold_pct\",\n                \"parameter\",\n                \"concentration\",\n                \"units\",\n                \"sample_type\",\n                \"current_site_name\",\n                \"sample_date\",\n                \"ts\",\n            ],\n            aliases=[\n                \"Town\",\n                \"% of threshold\",\n                \"Chemical\",\n                \"Concentration\",\n                \"Units\",\n                \"Sample type\",\n                \"Site name\",\n                \"Date\",\n                \"Treatment status\",\n            ],\n            style=\"font-size: medium\",\n            localize=True,\n        ).add_to(geo)\n\n        return m\n\n\n# Run the application\napp = App(app_ui, server)\n\nif __name__ == \"__main__\":\n    app.run()\n", "type": "text"}, {"name": "ratelimit.py", "content": "\"\"\"\nOriginally from this gist: https://gist.github.com/jcheng5/427de09573816c4ce3a8c6ec1839e7c0\nthanks to jcheng5\n\"\"\"\n\nimport functools\nimport time\n\nfrom shiny import reactive\n\n\ndef debounce(delay_secs):\n    def wrapper(f):\n        when = reactive.Value(None)\n        trigger = reactive.Value(0)\n\n        @reactive.Calc\n        def cached():\n            \"\"\"\n            Just in case f isn't a reactive calc already, wrap it in one. This ensures\n            that f() won't execute any more than it needs to.\n            \"\"\"\n            return f()\n\n        @reactive.Effect(priority=102)\n        def primer():\n            \"\"\"\n            Whenever cached() is invalidated, set a new deadline for when to let\n            downstream know--unless cached() invalidates again\n            \"\"\"\n            try:\n                cached()\n            except Exception:\n                ...\n            finally:\n                when.set(time.time() + delay_secs)\n\n        @reactive.Effect(priority=101)\n        def timer():\n            \"\"\"\n            Watches changes to the deadline and triggers downstream if it's expired; if\n            not, use invalidate_later to wait the necessary time and then try again.\n            \"\"\"\n            deadline = when()\n            if deadline is None:\n                return\n            time_left = deadline - time.time()\n            if time_left <= 0:\n                # The timer expired\n                with reactive.isolate():\n                    when.set(None)\n                    trigger.set(trigger() + 1)\n            else:\n                reactive.invalidate_later(time_left)\n\n        @reactive.Calc\n        @reactive.event(trigger, ignore_none=False)\n        @functools.wraps(f)\n        def debounced():\n            return cached()\n\n        return debounced\n\n    return wrapper\n\n\ndef throttle(delay_secs):\n    def wrapper(f):\n        last_signaled = reactive.Value(None)\n        last_triggered = reactive.Value(None)\n        trigger = reactive.Value(0)\n\n        @reactive.Calc\n        def cached():\n            return f()\n\n        @reactive.Effect(priority=102)\n        def primer():\n            try:\n                cached()\n            except Exception:\n                ...\n            finally:\n                last_signaled.set(time.time())\n\n        @reactive.Effect(priority=101)\n        def timer():\n            if last_triggered() is not None and last_signaled() < last_triggered():\n                return\n\n            now = time.time()\n            if last_triggered() is None or (now - last_triggered()) >= delay_secs:\n                last_triggered.set(now)\n                with reactive.isolate():\n                    trigger.set(trigger() + 1)\n            else:\n                reactive.invalidate_later(delay_secs - (now - last_triggered()))\n\n        @reactive.Calc\n        @reactive.event(trigger, ignore_none=False)\n        @functools.wraps(f)\n        def throttled():\n            return cached()\n\n        return throttled\n\n    return wrapper\n", "type": "text"}, {"name": "requirements.txt", "content": "folium==0.14.0\ngeopandas", "type": "text"}]